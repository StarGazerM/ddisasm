//===- elf_binaries.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//

// This module defines predicates and rules specific of ELF binaries
section(Name,Size,Addr):-
    binary_format("ELF"),
    section_complete(Name,Size,Addr,_,Flags,_),
    elf_section_flag("SHF_ALLOC",Pos_Alloc),
    Flags band (2^Pos_Alloc)  > 0.

.decl elf_section_flag(Name:symbol,Position:unsigned)
.output elf_section_flag

elf_section_flag("SHF_WRITE",0).
elf_section_flag("SHF_ALLOC",1).
elf_section_flag("SHF_EXECINSTR",2).
elf_section_flag("SHF_TLS",10).

.decl elf_section_type(Name:symbol,Code:unsigned)
.output elf_section_type

elf_section_type("NULL",0).
elf_section_type("PROGBITS",1).
elf_section_type("SYMTAB",2).
elf_section_type("STRTAB",3).
elf_section_type("RELA",4).
elf_section_type("HASH",5).
elf_section_type("DYNAMIC",6).
elf_section_type("NOTE",7).
elf_section_type("NOBITS",8).
elf_section_type("REL",9).
elf_section_type("SHLIB",10).
elf_section_type("DYNSYM",11).

elf_section_type("INIT_ARRAY",14).
elf_section_type("FINI_ARRAY",15).
elf_section_type("PREINIT_ARRAY",16).
elf_section_type("GROUP",17).
elf_section_type("SYMTAB_SHNDX",18).
elf_section_type("NUM",19).

data_section(Name):-
    section_complete(Name,_,_,Type,Flags,_),
    elf_section_flag("SHF_EXECINSTR",Pos_Exec), Flags band (2^Pos_Exec)  = 0,
    elf_section_flag("SHF_ALLOC",Pos_Alloc), Flags band (2^Pos_Alloc)  > 0,
    (   elf_section_type("PROGBITS",Type);
        elf_section_type("NOBITS",Type);
        elf_section_type("INIT_ARRAY",Type);
        elf_section_type("FINI_ARRAY",Type);
        elf_section_type("PREINIT_ARRAY",Type);
        elf_section_type("DYNAMIC",Type);
        elf_section_type("RELA",Type)
    ).

exception_section(".eh_frame").
exception_section(".eh_frame_hdr").
exception_section(".gcc_except_table").

special_data_section(Section):-
    exception_section(Section).

special_data_section(".dynamic").
special_data_section(".fini_array").
special_data_section(".got").
special_data_section(".got.plt").
special_data_section(".init_array").
special_data_section(".interp").
special_data_section(".jcr").
special_data_section(".tm_clone_table").

code_section(Name):-
    binary_format("ELF"),
    section_complete(Name,_,_,_,Flags,_),
    elf_section_flag("SHF_EXECINSTR",Pos_Exec), Flags band (2^Pos_Exec)  > 0.

function_pointer_section(".init_array"):-binary_format("ELF").
function_pointer_section(".fini_array"):-binary_format("ELF").
function_pointer_section(".got.plt"):-binary_format("ELF").
////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_section(name:symbol)
.output plt_section

plt_section(".plt").
plt_section(".plt.got").
plt_section(".plt.sec").

.decl got_section(name:symbol)
.output got_section

got_section(".got").
got_section(".got.plt").

tls_section(Name):-
    binary_format("ELF"),
    data_section(Name),
    section_complete(Name,_,_,_,Flags,_),
    elf_section_flag("SHF_TLS", Pos_Tls), Flags band (2^Pos_Tls) > 0.

bss_section(Name):-
    binary_format("ELF"),
    section_complete(Name,_,_,Type,Flags,_),
    elf_section_flag("SHF_ALLOC",Pos_Alloc), Flags band (2^Pos_Alloc) > 0,
    SHT_NOBITS = 8,
    Type = SHT_NOBITS.

non_zero_data_section(Name):-
    data_section(Name),
    !bss_section(Name),
    Name != ".dynamic".
////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_entry(ea:address, function:symbol)
.output plt_entry

plt_entry(EA,Function):-
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,
    pc_relative_jump(EA,Got_entry),
    relocation(Got_entry,_,Function,_),
    Function != "".

plt_entry(EA,Name):-
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,
    pc_relative_jump(EA,Got_entry),
    relocation(Got_entry,"IRELATIVE","",Dest),
    (
        defined_symbol(as(Dest,address),_,"GNU_IFUNC",_,_,_,_,Name);
        !defined_symbol(as(Dest,address),_,"GNU_IFUNC",_,_,_,_,_),
        ifunc_symbol(as(Dest,address),Name)
    ).

plt_block(Block,Function):-
    plt_entry(EA,Function),
    code_in_refined_block(EA,Block).

.decl plt_data_reference(ea:address)
.output plt_data_reference

plt_data_reference(EA):-
    plt_block(Dest,_),
    symbolic_data(EA,_,Dest).

//////////////////////////////////////////////////////////////////////////

got_reference(Got_entry,Symbol):-
    (
      pc_relative_operand(_,_,Got_entry);
      got_relative_operand(_,_,Got_entry)
    ),
    section(".got",Size,Beg),
    Got_entry >= Beg,
    Got_entry < Beg+Size,
    relocation(Got_entry,RelType,Symbol,_),
    RelType != "RELATIVE",
    (
      symbol(_,_,_,Scope,_,_,_,Symbol), Scope != "WEAK"
      ;
      // Handle `.weakref' directives that are sometime pseudo-weak references.
      symbol(0,0,"FUNC","WEAK",0,_,_,Symbol)
    ).

got_reference(Got_entry,Symbol):-
    (
      pc_relative_operand(_,_,Got_entry);
      got_relative_operand(_,_,Got_entry)
    ),
    section(".got",Size,Beg),
    Got_entry >= Beg,
    Got_entry < Beg+Size,
    symbolic_data(Got_entry,8,Dest),
    symbol(Dest,_,_,_,_,_,_,Symbol).

got_local_reference(Got_entry,Dest):-
    (
      pc_relative_operand(_,_,Got_entry);
      got_relative_operand(_,_,Got_entry)
    ),
    section(".got",Size,Beg),
    Got_entry >= Beg,
    Got_entry < Beg+Size,
    symbolic_data(Got_entry,8,Dest),
    !got_reference(Got_entry,_).


//////////////////////////////////////////////////////////////////////////
// find the main function even if it does not have a symbol
//
.decl start_function(ea:address)
.output start_function

start_function(EA):-
    binary_format("ELF"),
    function_symbol(EA,"_start").

start_function(Start_location):-
    binary_format("ELF"),
    !function_symbol(Start_location,"_start"),
    entry_point(Start_location).

main_function(EA):-
    binary_format("ELF"),
    function_symbol(EA,"main").

main_function(Main_location):-
    binary_format("ELF"),
    !function_symbol(Main_location,"main"),
    First_call = min EA:{
        start_function(Entry),
        instruction(EA,_,_,CallOp,_,_,_,_,_,_),
        arch.call_operation(CallOp),
        code(EA),
        EA>=Entry
    },
    next(Prev,First_call),
    code(Prev),
    symbolic_operand(Prev,1,Main_location,"code").

inferred_symbol_name(EA,"_start","GLOBAL","FUNC"):-
    start_function(EA).

inferred_symbol_name(EA,"__do_global_dtors_aux","LOCAL","FUNC"):-
    function_symbol(EA,"__do_global_dtors_aux").

inferred_symbol_name(EA,"__do_global_dtors_aux","LOCAL","FUNC"):-
    !function_symbol(EA,"__do_global_dtors_aux"),
    function_inference.function_entry(EA),
    // referenced from .fini_array
    address_in_data(FiniArray,EA),
    section(".fini_array",Size,Beg),
    FiniArray >= Beg,
    FiniArray < Beg+Size,
    // compare a value in bss with 0 in the first block
    code_in_refined_block(EA_cmp,EA),
    instruction(EA_cmp,_,_,"CMP",Op1,_,0,0,_,_),
    op_immediate(Op1,0),
    pc_relative_operand(EA_cmp,2,DataRef),
    bss_section(SectionName),
    section(SectionName,SizeBss,BegData),
    DataRef >= BegData,
    DataRef <= BegData+SizeBss.

inferred_symbol_name(EA,"_DYNAMIC","LOCAL","NONE"):-
    binary_format("ELF"),
    !symbol(EA,_,_,_,_,_,_,"_DYNAMIC"),
    section(".dynamic",_,EA).


no_return_function("exit"):-binary_format("ELF").
no_return_function("_exit"):-binary_format("ELF").
no_return_function("abort"):-binary_format("ELF").
no_return_function("__stack_chk_fail"):-binary_format("ELF").
no_return_function("__assert_fail"):-binary_format("ELF").
no_return_function("longjump"):-binary_format("ELF").


////////////////////////////////////////////////////////////////////////////////////////////

symbolic_expr_from_relocation(EA,8,Symbol,Addend):-
    binary_format("ELF"),
    relocation(EA,"R64",Symbol,Addend),
    symbol(_,_,_,_,_,_,_,Symbol).

symbolic_expr_from_relocation(EA,4,Symbol,Addend):-
    binary_format("ELF"),
    relocation(EA,"R32",Symbol,Addend),
    symbol(_,_,_,_,_,_,_,Symbol).

symbolic_expr_from_relocation(EA,4,Symbol,Addend):-
    binary_format("ELF"),
    relocation(EA,"R32S",Symbol,Addend),
    symbol(_,_,_,_,_,_,_,Symbol).

////////////////////////////////////////////////////////////////////////////////////////////

.decl tls_segment(Start:address,End:address,Align:unsigned)
.output tls_segment
tls_segment(Start,End,Align):-
    Start = min EA:{ tls_section(Name), section(Name,_,Addr), EA=Addr },
    End = max EA:{ tls_section(Name), section(Name,Size,Addr), EA=Addr+Size },
    Align = max X:{ tls_section(Name), section_complete(Name,_,_,_,_,X) }.

// Segment-based references to thread-local storage,
//   e.g.   mov     eax, DWORD PTR fs:i@tpoff
//     or   mov     eax, DWORD PTR fs:[-4]
symbolic_operand_candidate(EA,Index,as(Reference+Offset,address),"data"):-
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,"FS","NONE","NONE",_,Offset,_), Offset < 0,
    tls_segment(_,TlsEnd,Align),
    Reference = as(TlsEnd,number) + as(TlsEnd % max(Align,1),number).

//   e.g.  mov	rax, qword ptr fs:[0]
//         lea	rax, [rax + threadLocal@TPOFF]
symbolic_operand_candidate(EA_used,Index,as(Reference+Offset,address),"data"):-
    instruction_get_op(EA_def,_,Op_def),
    op_indirect(Op_def,"FS","NONE","NONE",_,0,_),
    def_used(EA_def,_,EA_used,Index),
    instruction_get_op(EA_used,Index,Op_used),
    op_indirect(Op_used,"NONE",_,_,_,Offset,_), Offset < 0,
    tls_segment(_,TlsEnd,Align),
    Reference = as(TlsEnd,number) + as(TlsEnd % max(Align,1),number).


////////////////////////////////////////////////////////////////////
// Static binaries

.decl ifunc_symbol(EA:address,Name:symbol)
.output ifunc_symbol

// We need two symbols, a function symbol and a GNU_IFUNC symbol
// so we can create a IRELATIVE relocation
ifunc_symbol(DestAddr,NameFunc),
inferred_symbol_name(DestAddr,NameFunc,"GLOBAL","GNU_IFUNC"),
inferred_symbol_name(DestAddr,Name,"LOCAL","FUNC"):-
    relocation(Got_entry,"IRELATIVE","",Dest),
    DestAddr = as(Dest,address),
    !symbol(DestAddr,_,"GNU_IFUNC",_,_,_,_,_),
    NameFunc = cat("FUN_",to_string(Dest)),
    Name = cat(NameFunc,"_ifunc").


// these symbols point to the begining and end of the iplt section
// that contaisn the IRELATIVE relocations
inferred_symbol_name(Beg,"__rela_iplt_start","GLOBAL","NONE"):-
    section(".rela.plt",_,Beg),
    !symbol(_,_,_,_,_,_,_,"__rela_iplt_start").

inferred_symbol_name(Beg+Size,"__rela_iplt_end","GLOBAL","NONE"):-
    section(".rela.plt",Size,Beg),
    !symbol(_,_,_,_,_,_,_,"__rela_iplt_end").

abi_intrinsic(Beg,"__rela_iplt_start"),
abi_intrinsic(Beg+Size,"__rela_iplt_end"):-
    section(".rela.plt",Size,Beg).



// Special loop pattern seen in `__run_exit_handlers`
// of libc ubuntu20
// The alignment for symbols introduced by the pprinter is causing crashes
//   mov RBX,OFFSET __start___libc_atexit
//   mov RAX,OFFSET __stop___libc_atexit
//   ...
//    sub RAX,1
//    sub RAX,RBX
//    shr RAX,3
//    lea R12,QWORD PTR [RBX+RAX*8+8]
//    ...
//    call QWORD PTR [RBX]
// __stop___libc_atexit has 16 alignment, which introduces a zero address
// in the list of pointer iterated by this code
// We rewrite the code above as:
//   mov RBX,OFFSET __start___libc_atexit
//   mov RAX,OFFSET __start___libc_atexit+ CONSTANT


moved_label_class(EAStop,ImmIndexStop,"libc atexit"),
moved_immediate_candidate(EAStop,ImmIndexStop,ImmediateStopAddr,ImmediateStartAddr):-
    mov_immediate_to_reg(EAStart,_,_,ImmediateStart),
    ImmediateStartAddr = as(ImmediateStart, address),
    defined_symbol(ImmediateStartAddr,_,_,_,_,_,_,"__start___libc_atexit"),
    next(EAStart,EAStop),
    mov_immediate_to_reg(EAStop,_,ImmIndexStop,ImmediateStop),
    ImmediateStopAddr = as(ImmediateStop, address),
    defined_symbol(ImmediateStopAddr,_,_,_,_,_,_,"__stop___libc_atexit").
